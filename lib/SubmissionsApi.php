<?php
/**
 * SubmissionsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Docuseal
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * DocuSeal API
 *
 * DocuSeal API specs
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: admin@docuseal.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Docuseal\Docuseal;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Docuseal\ApiException;
use Docuseal\Configuration;
use Docuseal\HeaderSelector;
use Docuseal\ObjectSerializer;

/**
 * SubmissionsApi Class Doc Comment
 *
 * @category Class
 * @package  Docuseal
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class SubmissionsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'archiveSubmission' => [
            'application/json',
        ],
        'createSubmission' => [
            'application/json',
        ],
        'createSubmissionsFromEmails' => [
            'application/json',
        ],
        'getSubmission' => [
            'application/json',
        ],
        'getSubmissions' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation archiveSubmission
     *
     * Archive a submission
     *
     * @param  int $id The unique identifier of the submission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveSubmission'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Docuseal\Model\ArchiveSubmission200Response
     */
    public function archiveSubmission($id, string $contentType = self::contentTypes['archiveSubmission'][0])
    {
        list($response) = $this->archiveSubmissionWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation archiveSubmissionWithHttpInfo
     *
     * Archive a submission
     *
     * @param  int $id The unique identifier of the submission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveSubmission'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Docuseal\Model\ArchiveSubmission200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function archiveSubmissionWithHttpInfo($id, string $contentType = self::contentTypes['archiveSubmission'][0])
    {
        $request = $this->archiveSubmissionRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Docuseal\Model\ArchiveSubmission200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Docuseal\Model\ArchiveSubmission200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Docuseal\Model\ArchiveSubmission200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Docuseal\Model\ArchiveSubmission200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Docuseal\Model\ArchiveSubmission200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation archiveSubmissionAsync
     *
     * Archive a submission
     *
     * @param  int $id The unique identifier of the submission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function archiveSubmissionAsync($id, string $contentType = self::contentTypes['archiveSubmission'][0])
    {
        return $this->archiveSubmissionAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation archiveSubmissionAsyncWithHttpInfo
     *
     * Archive a submission
     *
     * @param  int $id The unique identifier of the submission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function archiveSubmissionAsyncWithHttpInfo($id, string $contentType = self::contentTypes['archiveSubmission'][0])
    {
        $returnType = '\Docuseal\Model\ArchiveSubmission200Response';
        $request = $this->archiveSubmissionRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'archiveSubmission'
     *
     * @param  int $id The unique identifier of the submission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function archiveSubmissionRequest($id, string $contentType = self::contentTypes['archiveSubmission'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling archiveSubmission'
            );
        }


        $resourcePath = '/submissions/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Auth-Token');
        if ($apiKey !== null) {
            $headers['X-Auth-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createSubmission
     *
     * Create a submission
     *
     * @param  \Docuseal\Model\CreateSubmissionRequest $create_submission_request create_submission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubmission'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Docuseal\Model\CreateSubmission200ResponseInner[]
     */
    public function createSubmission($create_submission_request, string $contentType = self::contentTypes['createSubmission'][0])
    {
        list($response) = $this->createSubmissionWithHttpInfo($create_submission_request, $contentType);
        return $response;
    }

    /**
     * Operation createSubmissionWithHttpInfo
     *
     * Create a submission
     *
     * @param  \Docuseal\Model\CreateSubmissionRequest $create_submission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubmission'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Docuseal\Model\CreateSubmission200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createSubmissionWithHttpInfo($create_submission_request, string $contentType = self::contentTypes['createSubmission'][0])
    {
        $request = $this->createSubmissionRequest($create_submission_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Docuseal\Model\CreateSubmission200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Docuseal\Model\CreateSubmission200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Docuseal\Model\CreateSubmission200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Docuseal\Model\CreateSubmission200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Docuseal\Model\CreateSubmission200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createSubmissionAsync
     *
     * Create a submission
     *
     * @param  \Docuseal\Model\CreateSubmissionRequest $create_submission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSubmissionAsync($create_submission_request, string $contentType = self::contentTypes['createSubmission'][0])
    {
        return $this->createSubmissionAsyncWithHttpInfo($create_submission_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createSubmissionAsyncWithHttpInfo
     *
     * Create a submission
     *
     * @param  \Docuseal\Model\CreateSubmissionRequest $create_submission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSubmissionAsyncWithHttpInfo($create_submission_request, string $contentType = self::contentTypes['createSubmission'][0])
    {
        $returnType = '\Docuseal\Model\CreateSubmission200ResponseInner[]';
        $request = $this->createSubmissionRequest($create_submission_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createSubmission'
     *
     * @param  \Docuseal\Model\CreateSubmissionRequest $create_submission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createSubmissionRequest($create_submission_request, string $contentType = self::contentTypes['createSubmission'][0])
    {

        // verify the required parameter 'create_submission_request' is set
        if ($create_submission_request === null || (is_array($create_submission_request) && count($create_submission_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_submission_request when calling createSubmission'
            );
        }


        $resourcePath = '/submissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_submission_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_submission_request));
            } else {
                $httpBody = $create_submission_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Auth-Token');
        if ($apiKey !== null) {
            $headers['X-Auth-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createSubmissionsFromEmails
     *
     * Create submissions from emails
     *
     * @param  \Docuseal\Model\CreateSubmissionsFromEmailsRequest $create_submissions_from_emails_request create_submissions_from_emails_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubmissionsFromEmails'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Docuseal\Model\CreateSubmission200ResponseInner[]
     */
    public function createSubmissionsFromEmails($create_submissions_from_emails_request, string $contentType = self::contentTypes['createSubmissionsFromEmails'][0])
    {
        list($response) = $this->createSubmissionsFromEmailsWithHttpInfo($create_submissions_from_emails_request, $contentType);
        return $response;
    }

    /**
     * Operation createSubmissionsFromEmailsWithHttpInfo
     *
     * Create submissions from emails
     *
     * @param  \Docuseal\Model\CreateSubmissionsFromEmailsRequest $create_submissions_from_emails_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubmissionsFromEmails'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Docuseal\Model\CreateSubmission200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createSubmissionsFromEmailsWithHttpInfo($create_submissions_from_emails_request, string $contentType = self::contentTypes['createSubmissionsFromEmails'][0])
    {
        $request = $this->createSubmissionsFromEmailsRequest($create_submissions_from_emails_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Docuseal\Model\CreateSubmission200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Docuseal\Model\CreateSubmission200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Docuseal\Model\CreateSubmission200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Docuseal\Model\CreateSubmission200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Docuseal\Model\CreateSubmission200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createSubmissionsFromEmailsAsync
     *
     * Create submissions from emails
     *
     * @param  \Docuseal\Model\CreateSubmissionsFromEmailsRequest $create_submissions_from_emails_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubmissionsFromEmails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSubmissionsFromEmailsAsync($create_submissions_from_emails_request, string $contentType = self::contentTypes['createSubmissionsFromEmails'][0])
    {
        return $this->createSubmissionsFromEmailsAsyncWithHttpInfo($create_submissions_from_emails_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createSubmissionsFromEmailsAsyncWithHttpInfo
     *
     * Create submissions from emails
     *
     * @param  \Docuseal\Model\CreateSubmissionsFromEmailsRequest $create_submissions_from_emails_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubmissionsFromEmails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSubmissionsFromEmailsAsyncWithHttpInfo($create_submissions_from_emails_request, string $contentType = self::contentTypes['createSubmissionsFromEmails'][0])
    {
        $returnType = '\Docuseal\Model\CreateSubmission200ResponseInner[]';
        $request = $this->createSubmissionsFromEmailsRequest($create_submissions_from_emails_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createSubmissionsFromEmails'
     *
     * @param  \Docuseal\Model\CreateSubmissionsFromEmailsRequest $create_submissions_from_emails_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSubmissionsFromEmails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createSubmissionsFromEmailsRequest($create_submissions_from_emails_request, string $contentType = self::contentTypes['createSubmissionsFromEmails'][0])
    {

        // verify the required parameter 'create_submissions_from_emails_request' is set
        if ($create_submissions_from_emails_request === null || (is_array($create_submissions_from_emails_request) && count($create_submissions_from_emails_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_submissions_from_emails_request when calling createSubmissionsFromEmails'
            );
        }


        $resourcePath = '/submissions/emails';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_submissions_from_emails_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_submissions_from_emails_request));
            } else {
                $httpBody = $create_submissions_from_emails_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Auth-Token');
        if ($apiKey !== null) {
            $headers['X-Auth-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSubmission
     *
     * Get a submission
     *
     * @param  int $id The unique identifier of the submission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmission'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Docuseal\Model\GetSubmission200Response
     */
    public function getSubmission($id, string $contentType = self::contentTypes['getSubmission'][0])
    {
        list($response) = $this->getSubmissionWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getSubmissionWithHttpInfo
     *
     * Get a submission
     *
     * @param  int $id The unique identifier of the submission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmission'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Docuseal\Model\GetSubmission200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSubmissionWithHttpInfo($id, string $contentType = self::contentTypes['getSubmission'][0])
    {
        $request = $this->getSubmissionRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Docuseal\Model\GetSubmission200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Docuseal\Model\GetSubmission200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Docuseal\Model\GetSubmission200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Docuseal\Model\GetSubmission200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Docuseal\Model\GetSubmission200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSubmissionAsync
     *
     * Get a submission
     *
     * @param  int $id The unique identifier of the submission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubmissionAsync($id, string $contentType = self::contentTypes['getSubmission'][0])
    {
        return $this->getSubmissionAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSubmissionAsyncWithHttpInfo
     *
     * Get a submission
     *
     * @param  int $id The unique identifier of the submission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubmissionAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getSubmission'][0])
    {
        $returnType = '\Docuseal\Model\GetSubmission200Response';
        $request = $this->getSubmissionRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSubmission'
     *
     * @param  int $id The unique identifier of the submission. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSubmissionRequest($id, string $contentType = self::contentTypes['getSubmission'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getSubmission'
            );
        }


        $resourcePath = '/submissions/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Auth-Token');
        if ($apiKey !== null) {
            $headers['X-Auth-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSubmissions
     *
     * List all submissions
     *
     * @param  int $template_id The template ID allows you to receive only the submissions created from that specific template. (optional)
     * @param  string $q Filter submissions based on submitters name, email or phone partial match. (optional)
     * @param  string $template_folder Filter submissions by template folder name. (optional)
     * @param  int $limit The number of submissions to return. Default value is 10. Maximum value is 100. (optional)
     * @param  int $after The unique identifier of the submission to start the list from. It allows you to receive only submissions with an ID greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of submissions. (optional)
     * @param  int $before The unique identifier of the submission that marks the end of the list. It allows you to receive only submissions with an ID less than the specified value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmissions'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Docuseal\Model\GetSubmissions200Response
     */
    public function getSubmissions($template_id = null, $q = null, $template_folder = null, $limit = null, $after = null, $before = null, string $contentType = self::contentTypes['getSubmissions'][0])
    {
        list($response) = $this->getSubmissionsWithHttpInfo($template_id, $q, $template_folder, $limit, $after, $before, $contentType);
        return $response;
    }

    /**
     * Operation getSubmissionsWithHttpInfo
     *
     * List all submissions
     *
     * @param  int $template_id The template ID allows you to receive only the submissions created from that specific template. (optional)
     * @param  string $q Filter submissions based on submitters name, email or phone partial match. (optional)
     * @param  string $template_folder Filter submissions by template folder name. (optional)
     * @param  int $limit The number of submissions to return. Default value is 10. Maximum value is 100. (optional)
     * @param  int $after The unique identifier of the submission to start the list from. It allows you to receive only submissions with an ID greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of submissions. (optional)
     * @param  int $before The unique identifier of the submission that marks the end of the list. It allows you to receive only submissions with an ID less than the specified value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmissions'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Docuseal\Model\GetSubmissions200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSubmissionsWithHttpInfo($template_id = null, $q = null, $template_folder = null, $limit = null, $after = null, $before = null, string $contentType = self::contentTypes['getSubmissions'][0])
    {
        $request = $this->getSubmissionsRequest($template_id, $q, $template_folder, $limit, $after, $before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Docuseal\Model\GetSubmissions200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Docuseal\Model\GetSubmissions200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Docuseal\Model\GetSubmissions200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Docuseal\Model\GetSubmissions200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Docuseal\Model\GetSubmissions200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSubmissionsAsync
     *
     * List all submissions
     *
     * @param  int $template_id The template ID allows you to receive only the submissions created from that specific template. (optional)
     * @param  string $q Filter submissions based on submitters name, email or phone partial match. (optional)
     * @param  string $template_folder Filter submissions by template folder name. (optional)
     * @param  int $limit The number of submissions to return. Default value is 10. Maximum value is 100. (optional)
     * @param  int $after The unique identifier of the submission to start the list from. It allows you to receive only submissions with an ID greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of submissions. (optional)
     * @param  int $before The unique identifier of the submission that marks the end of the list. It allows you to receive only submissions with an ID less than the specified value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubmissionsAsync($template_id = null, $q = null, $template_folder = null, $limit = null, $after = null, $before = null, string $contentType = self::contentTypes['getSubmissions'][0])
    {
        return $this->getSubmissionsAsyncWithHttpInfo($template_id, $q, $template_folder, $limit, $after, $before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSubmissionsAsyncWithHttpInfo
     *
     * List all submissions
     *
     * @param  int $template_id The template ID allows you to receive only the submissions created from that specific template. (optional)
     * @param  string $q Filter submissions based on submitters name, email or phone partial match. (optional)
     * @param  string $template_folder Filter submissions by template folder name. (optional)
     * @param  int $limit The number of submissions to return. Default value is 10. Maximum value is 100. (optional)
     * @param  int $after The unique identifier of the submission to start the list from. It allows you to receive only submissions with an ID greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of submissions. (optional)
     * @param  int $before The unique identifier of the submission that marks the end of the list. It allows you to receive only submissions with an ID less than the specified value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSubmissionsAsyncWithHttpInfo($template_id = null, $q = null, $template_folder = null, $limit = null, $after = null, $before = null, string $contentType = self::contentTypes['getSubmissions'][0])
    {
        $returnType = '\Docuseal\Model\GetSubmissions200Response';
        $request = $this->getSubmissionsRequest($template_id, $q, $template_folder, $limit, $after, $before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSubmissions'
     *
     * @param  int $template_id The template ID allows you to receive only the submissions created from that specific template. (optional)
     * @param  string $q Filter submissions based on submitters name, email or phone partial match. (optional)
     * @param  string $template_folder Filter submissions by template folder name. (optional)
     * @param  int $limit The number of submissions to return. Default value is 10. Maximum value is 100. (optional)
     * @param  int $after The unique identifier of the submission to start the list from. It allows you to receive only submissions with an ID greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of submissions. (optional)
     * @param  int $before The unique identifier of the submission that marks the end of the list. It allows you to receive only submissions with an ID less than the specified value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSubmissionsRequest($template_id = null, $q = null, $template_folder = null, $limit = null, $after = null, $before = null, string $contentType = self::contentTypes['getSubmissions'][0])
    {








        $resourcePath = '/submissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $template_id,
            'template_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $template_folder,
            'template_folder', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after,
            'after', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Auth-Token');
        if ($apiKey !== null) {
            $headers['X-Auth-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
