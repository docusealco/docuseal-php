<?php
/**
 * TemplatesApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Docuseal
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * DocuSeal API
 *
 * DocuSeal API specs
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: admin@docuseal.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Docuseal\Docuseal;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Docuseal\ApiException;
use Docuseal\Configuration;
use Docuseal\HeaderSelector;
use Docuseal\ObjectSerializer;

/**
 * TemplatesApi Class Doc Comment
 *
 * @category Class
 * @package  Docuseal
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class TemplatesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addDocumentToTemplate' => [
            'application/json',
        ],
        'archiveTemplate' => [
            'application/json',
        ],
        'cloneTemplate' => [
            'application/json',
        ],
        'createTemplateFromDocx' => [
            'application/json',
        ],
        'createTemplateFromHtml' => [
            'application/json',
        ],
        'createTemplateFromPdf' => [
            'application/json',
        ],
        'getTemplate' => [
            'application/json',
        ],
        'getTemplates' => [
            'application/json',
        ],
        'mergeTemplate' => [
            'application/json',
        ],
        'updateTemplate' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addDocumentToTemplate
     *
     * Update template documents
     *
     * @param  int $id The unique identifier of the documents template. (required)
     * @param  \Docuseal\Model\AddDocumentToTemplateRequest $add_document_to_template_request add_document_to_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addDocumentToTemplate'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Docuseal\Model\GetTemplates200ResponseDataInner
     */
    public function addDocumentToTemplate($id, $add_document_to_template_request, string $contentType = self::contentTypes['addDocumentToTemplate'][0])
    {
        list($response) = $this->addDocumentToTemplateWithHttpInfo($id, $add_document_to_template_request, $contentType);
        return $response;
    }

    /**
     * Operation addDocumentToTemplateWithHttpInfo
     *
     * Update template documents
     *
     * @param  int $id The unique identifier of the documents template. (required)
     * @param  \Docuseal\Model\AddDocumentToTemplateRequest $add_document_to_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addDocumentToTemplate'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Docuseal\Model\GetTemplates200ResponseDataInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function addDocumentToTemplateWithHttpInfo($id, $add_document_to_template_request, string $contentType = self::contentTypes['addDocumentToTemplate'][0])
    {
        $request = $this->addDocumentToTemplateRequest($id, $add_document_to_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Docuseal\Model\GetTemplates200ResponseDataInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Docuseal\Model\GetTemplates200ResponseDataInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Docuseal\Model\GetTemplates200ResponseDataInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Docuseal\Model\GetTemplates200ResponseDataInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Docuseal\Model\GetTemplates200ResponseDataInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addDocumentToTemplateAsync
     *
     * Update template documents
     *
     * @param  int $id The unique identifier of the documents template. (required)
     * @param  \Docuseal\Model\AddDocumentToTemplateRequest $add_document_to_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addDocumentToTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addDocumentToTemplateAsync($id, $add_document_to_template_request, string $contentType = self::contentTypes['addDocumentToTemplate'][0])
    {
        return $this->addDocumentToTemplateAsyncWithHttpInfo($id, $add_document_to_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addDocumentToTemplateAsyncWithHttpInfo
     *
     * Update template documents
     *
     * @param  int $id The unique identifier of the documents template. (required)
     * @param  \Docuseal\Model\AddDocumentToTemplateRequest $add_document_to_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addDocumentToTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addDocumentToTemplateAsyncWithHttpInfo($id, $add_document_to_template_request, string $contentType = self::contentTypes['addDocumentToTemplate'][0])
    {
        $returnType = '\Docuseal\Model\GetTemplates200ResponseDataInner';
        $request = $this->addDocumentToTemplateRequest($id, $add_document_to_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addDocumentToTemplate'
     *
     * @param  int $id The unique identifier of the documents template. (required)
     * @param  \Docuseal\Model\AddDocumentToTemplateRequest $add_document_to_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addDocumentToTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addDocumentToTemplateRequest($id, $add_document_to_template_request, string $contentType = self::contentTypes['addDocumentToTemplate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling addDocumentToTemplate'
            );
        }

        // verify the required parameter 'add_document_to_template_request' is set
        if ($add_document_to_template_request === null || (is_array($add_document_to_template_request) && count($add_document_to_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $add_document_to_template_request when calling addDocumentToTemplate'
            );
        }


        $resourcePath = '/templates/{id}/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($add_document_to_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($add_document_to_template_request));
            } else {
                $httpBody = $add_document_to_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Auth-Token');
        if ($apiKey !== null) {
            $headers['X-Auth-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation archiveTemplate
     *
     * Archive a template
     *
     * @param  int $id The unique identifier of the document template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveTemplate'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Docuseal\Model\ArchiveTemplate200Response
     */
    public function archiveTemplate($id, string $contentType = self::contentTypes['archiveTemplate'][0])
    {
        list($response) = $this->archiveTemplateWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation archiveTemplateWithHttpInfo
     *
     * Archive a template
     *
     * @param  int $id The unique identifier of the document template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveTemplate'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Docuseal\Model\ArchiveTemplate200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function archiveTemplateWithHttpInfo($id, string $contentType = self::contentTypes['archiveTemplate'][0])
    {
        $request = $this->archiveTemplateRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Docuseal\Model\ArchiveTemplate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Docuseal\Model\ArchiveTemplate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Docuseal\Model\ArchiveTemplate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Docuseal\Model\ArchiveTemplate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Docuseal\Model\ArchiveTemplate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation archiveTemplateAsync
     *
     * Archive a template
     *
     * @param  int $id The unique identifier of the document template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function archiveTemplateAsync($id, string $contentType = self::contentTypes['archiveTemplate'][0])
    {
        return $this->archiveTemplateAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation archiveTemplateAsyncWithHttpInfo
     *
     * Archive a template
     *
     * @param  int $id The unique identifier of the document template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function archiveTemplateAsyncWithHttpInfo($id, string $contentType = self::contentTypes['archiveTemplate'][0])
    {
        $returnType = '\Docuseal\Model\ArchiveTemplate200Response';
        $request = $this->archiveTemplateRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'archiveTemplate'
     *
     * @param  int $id The unique identifier of the document template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function archiveTemplateRequest($id, string $contentType = self::contentTypes['archiveTemplate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling archiveTemplate'
            );
        }


        $resourcePath = '/templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Auth-Token');
        if ($apiKey !== null) {
            $headers['X-Auth-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloneTemplate
     *
     * Clone a template
     *
     * @param  int $id The unique identifier of the documents template. (required)
     * @param  \Docuseal\Model\CloneTemplateRequest $clone_template_request clone_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloneTemplate'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Docuseal\Model\GetTemplates200ResponseDataInner
     */
    public function cloneTemplate($id, $clone_template_request, string $contentType = self::contentTypes['cloneTemplate'][0])
    {
        list($response) = $this->cloneTemplateWithHttpInfo($id, $clone_template_request, $contentType);
        return $response;
    }

    /**
     * Operation cloneTemplateWithHttpInfo
     *
     * Clone a template
     *
     * @param  int $id The unique identifier of the documents template. (required)
     * @param  \Docuseal\Model\CloneTemplateRequest $clone_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloneTemplate'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Docuseal\Model\GetTemplates200ResponseDataInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloneTemplateWithHttpInfo($id, $clone_template_request, string $contentType = self::contentTypes['cloneTemplate'][0])
    {
        $request = $this->cloneTemplateRequest($id, $clone_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Docuseal\Model\GetTemplates200ResponseDataInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Docuseal\Model\GetTemplates200ResponseDataInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Docuseal\Model\GetTemplates200ResponseDataInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Docuseal\Model\GetTemplates200ResponseDataInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Docuseal\Model\GetTemplates200ResponseDataInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloneTemplateAsync
     *
     * Clone a template
     *
     * @param  int $id The unique identifier of the documents template. (required)
     * @param  \Docuseal\Model\CloneTemplateRequest $clone_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloneTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloneTemplateAsync($id, $clone_template_request, string $contentType = self::contentTypes['cloneTemplate'][0])
    {
        return $this->cloneTemplateAsyncWithHttpInfo($id, $clone_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloneTemplateAsyncWithHttpInfo
     *
     * Clone a template
     *
     * @param  int $id The unique identifier of the documents template. (required)
     * @param  \Docuseal\Model\CloneTemplateRequest $clone_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloneTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloneTemplateAsyncWithHttpInfo($id, $clone_template_request, string $contentType = self::contentTypes['cloneTemplate'][0])
    {
        $returnType = '\Docuseal\Model\GetTemplates200ResponseDataInner';
        $request = $this->cloneTemplateRequest($id, $clone_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloneTemplate'
     *
     * @param  int $id The unique identifier of the documents template. (required)
     * @param  \Docuseal\Model\CloneTemplateRequest $clone_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloneTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloneTemplateRequest($id, $clone_template_request, string $contentType = self::contentTypes['cloneTemplate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloneTemplate'
            );
        }

        // verify the required parameter 'clone_template_request' is set
        if ($clone_template_request === null || (is_array($clone_template_request) && count($clone_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $clone_template_request when calling cloneTemplate'
            );
        }


        $resourcePath = '/templates/{id}/clone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($clone_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($clone_template_request));
            } else {
                $httpBody = $clone_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Auth-Token');
        if ($apiKey !== null) {
            $headers['X-Auth-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTemplateFromDocx
     *
     * Create a template from Word DOCX
     *
     * @param  \Docuseal\Model\CreateTemplateFromDocxRequest $create_template_from_docx_request create_template_from_docx_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplateFromDocx'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Docuseal\Model\GetTemplates200ResponseDataInner
     */
    public function createTemplateFromDocx($create_template_from_docx_request, string $contentType = self::contentTypes['createTemplateFromDocx'][0])
    {
        list($response) = $this->createTemplateFromDocxWithHttpInfo($create_template_from_docx_request, $contentType);
        return $response;
    }

    /**
     * Operation createTemplateFromDocxWithHttpInfo
     *
     * Create a template from Word DOCX
     *
     * @param  \Docuseal\Model\CreateTemplateFromDocxRequest $create_template_from_docx_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplateFromDocx'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Docuseal\Model\GetTemplates200ResponseDataInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTemplateFromDocxWithHttpInfo($create_template_from_docx_request, string $contentType = self::contentTypes['createTemplateFromDocx'][0])
    {
        $request = $this->createTemplateFromDocxRequest($create_template_from_docx_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Docuseal\Model\GetTemplates200ResponseDataInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Docuseal\Model\GetTemplates200ResponseDataInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Docuseal\Model\GetTemplates200ResponseDataInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Docuseal\Model\GetTemplates200ResponseDataInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Docuseal\Model\GetTemplates200ResponseDataInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTemplateFromDocxAsync
     *
     * Create a template from Word DOCX
     *
     * @param  \Docuseal\Model\CreateTemplateFromDocxRequest $create_template_from_docx_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplateFromDocx'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTemplateFromDocxAsync($create_template_from_docx_request, string $contentType = self::contentTypes['createTemplateFromDocx'][0])
    {
        return $this->createTemplateFromDocxAsyncWithHttpInfo($create_template_from_docx_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTemplateFromDocxAsyncWithHttpInfo
     *
     * Create a template from Word DOCX
     *
     * @param  \Docuseal\Model\CreateTemplateFromDocxRequest $create_template_from_docx_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplateFromDocx'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTemplateFromDocxAsyncWithHttpInfo($create_template_from_docx_request, string $contentType = self::contentTypes['createTemplateFromDocx'][0])
    {
        $returnType = '\Docuseal\Model\GetTemplates200ResponseDataInner';
        $request = $this->createTemplateFromDocxRequest($create_template_from_docx_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTemplateFromDocx'
     *
     * @param  \Docuseal\Model\CreateTemplateFromDocxRequest $create_template_from_docx_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplateFromDocx'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTemplateFromDocxRequest($create_template_from_docx_request, string $contentType = self::contentTypes['createTemplateFromDocx'][0])
    {

        // verify the required parameter 'create_template_from_docx_request' is set
        if ($create_template_from_docx_request === null || (is_array($create_template_from_docx_request) && count($create_template_from_docx_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_template_from_docx_request when calling createTemplateFromDocx'
            );
        }


        $resourcePath = '/templates/docx';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_template_from_docx_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_template_from_docx_request));
            } else {
                $httpBody = $create_template_from_docx_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Auth-Token');
        if ($apiKey !== null) {
            $headers['X-Auth-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTemplateFromHtml
     *
     * Create a template from HTML
     *
     * @param  \Docuseal\Model\CreateTemplateFromHtmlRequest $create_template_from_html_request create_template_from_html_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplateFromHtml'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Docuseal\Model\GetTemplates200ResponseDataInner
     */
    public function createTemplateFromHtml($create_template_from_html_request, string $contentType = self::contentTypes['createTemplateFromHtml'][0])
    {
        list($response) = $this->createTemplateFromHtmlWithHttpInfo($create_template_from_html_request, $contentType);
        return $response;
    }

    /**
     * Operation createTemplateFromHtmlWithHttpInfo
     *
     * Create a template from HTML
     *
     * @param  \Docuseal\Model\CreateTemplateFromHtmlRequest $create_template_from_html_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplateFromHtml'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Docuseal\Model\GetTemplates200ResponseDataInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTemplateFromHtmlWithHttpInfo($create_template_from_html_request, string $contentType = self::contentTypes['createTemplateFromHtml'][0])
    {
        $request = $this->createTemplateFromHtmlRequest($create_template_from_html_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Docuseal\Model\GetTemplates200ResponseDataInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Docuseal\Model\GetTemplates200ResponseDataInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Docuseal\Model\GetTemplates200ResponseDataInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Docuseal\Model\GetTemplates200ResponseDataInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Docuseal\Model\GetTemplates200ResponseDataInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTemplateFromHtmlAsync
     *
     * Create a template from HTML
     *
     * @param  \Docuseal\Model\CreateTemplateFromHtmlRequest $create_template_from_html_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplateFromHtml'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTemplateFromHtmlAsync($create_template_from_html_request, string $contentType = self::contentTypes['createTemplateFromHtml'][0])
    {
        return $this->createTemplateFromHtmlAsyncWithHttpInfo($create_template_from_html_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTemplateFromHtmlAsyncWithHttpInfo
     *
     * Create a template from HTML
     *
     * @param  \Docuseal\Model\CreateTemplateFromHtmlRequest $create_template_from_html_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplateFromHtml'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTemplateFromHtmlAsyncWithHttpInfo($create_template_from_html_request, string $contentType = self::contentTypes['createTemplateFromHtml'][0])
    {
        $returnType = '\Docuseal\Model\GetTemplates200ResponseDataInner';
        $request = $this->createTemplateFromHtmlRequest($create_template_from_html_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTemplateFromHtml'
     *
     * @param  \Docuseal\Model\CreateTemplateFromHtmlRequest $create_template_from_html_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplateFromHtml'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTemplateFromHtmlRequest($create_template_from_html_request, string $contentType = self::contentTypes['createTemplateFromHtml'][0])
    {

        // verify the required parameter 'create_template_from_html_request' is set
        if ($create_template_from_html_request === null || (is_array($create_template_from_html_request) && count($create_template_from_html_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_template_from_html_request when calling createTemplateFromHtml'
            );
        }


        $resourcePath = '/templates/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_template_from_html_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_template_from_html_request));
            } else {
                $httpBody = $create_template_from_html_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Auth-Token');
        if ($apiKey !== null) {
            $headers['X-Auth-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTemplateFromPdf
     *
     * Create a template from existing PDF
     *
     * @param  \Docuseal\Model\CreateTemplateFromPdfRequest $create_template_from_pdf_request create_template_from_pdf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplateFromPdf'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Docuseal\Model\GetTemplates200ResponseDataInner
     */
    public function createTemplateFromPdf($create_template_from_pdf_request, string $contentType = self::contentTypes['createTemplateFromPdf'][0])
    {
        list($response) = $this->createTemplateFromPdfWithHttpInfo($create_template_from_pdf_request, $contentType);
        return $response;
    }

    /**
     * Operation createTemplateFromPdfWithHttpInfo
     *
     * Create a template from existing PDF
     *
     * @param  \Docuseal\Model\CreateTemplateFromPdfRequest $create_template_from_pdf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplateFromPdf'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Docuseal\Model\GetTemplates200ResponseDataInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTemplateFromPdfWithHttpInfo($create_template_from_pdf_request, string $contentType = self::contentTypes['createTemplateFromPdf'][0])
    {
        $request = $this->createTemplateFromPdfRequest($create_template_from_pdf_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Docuseal\Model\GetTemplates200ResponseDataInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Docuseal\Model\GetTemplates200ResponseDataInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Docuseal\Model\GetTemplates200ResponseDataInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Docuseal\Model\GetTemplates200ResponseDataInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Docuseal\Model\GetTemplates200ResponseDataInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTemplateFromPdfAsync
     *
     * Create a template from existing PDF
     *
     * @param  \Docuseal\Model\CreateTemplateFromPdfRequest $create_template_from_pdf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplateFromPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTemplateFromPdfAsync($create_template_from_pdf_request, string $contentType = self::contentTypes['createTemplateFromPdf'][0])
    {
        return $this->createTemplateFromPdfAsyncWithHttpInfo($create_template_from_pdf_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTemplateFromPdfAsyncWithHttpInfo
     *
     * Create a template from existing PDF
     *
     * @param  \Docuseal\Model\CreateTemplateFromPdfRequest $create_template_from_pdf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplateFromPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTemplateFromPdfAsyncWithHttpInfo($create_template_from_pdf_request, string $contentType = self::contentTypes['createTemplateFromPdf'][0])
    {
        $returnType = '\Docuseal\Model\GetTemplates200ResponseDataInner';
        $request = $this->createTemplateFromPdfRequest($create_template_from_pdf_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTemplateFromPdf'
     *
     * @param  \Docuseal\Model\CreateTemplateFromPdfRequest $create_template_from_pdf_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTemplateFromPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTemplateFromPdfRequest($create_template_from_pdf_request, string $contentType = self::contentTypes['createTemplateFromPdf'][0])
    {

        // verify the required parameter 'create_template_from_pdf_request' is set
        if ($create_template_from_pdf_request === null || (is_array($create_template_from_pdf_request) && count($create_template_from_pdf_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_template_from_pdf_request when calling createTemplateFromPdf'
            );
        }


        $resourcePath = '/templates/pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_template_from_pdf_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_template_from_pdf_request));
            } else {
                $httpBody = $create_template_from_pdf_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Auth-Token');
        if ($apiKey !== null) {
            $headers['X-Auth-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTemplate
     *
     * Get a template
     *
     * @param  int $id The unique identifier of the document template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplate'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Docuseal\Model\GetTemplates200ResponseDataInner
     */
    public function getTemplate($id, string $contentType = self::contentTypes['getTemplate'][0])
    {
        list($response) = $this->getTemplateWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getTemplateWithHttpInfo
     *
     * Get a template
     *
     * @param  int $id The unique identifier of the document template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplate'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Docuseal\Model\GetTemplates200ResponseDataInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTemplateWithHttpInfo($id, string $contentType = self::contentTypes['getTemplate'][0])
    {
        $request = $this->getTemplateRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Docuseal\Model\GetTemplates200ResponseDataInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Docuseal\Model\GetTemplates200ResponseDataInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Docuseal\Model\GetTemplates200ResponseDataInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Docuseal\Model\GetTemplates200ResponseDataInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Docuseal\Model\GetTemplates200ResponseDataInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTemplateAsync
     *
     * Get a template
     *
     * @param  int $id The unique identifier of the document template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplateAsync($id, string $contentType = self::contentTypes['getTemplate'][0])
    {
        return $this->getTemplateAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTemplateAsyncWithHttpInfo
     *
     * Get a template
     *
     * @param  int $id The unique identifier of the document template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplateAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getTemplate'][0])
    {
        $returnType = '\Docuseal\Model\GetTemplates200ResponseDataInner';
        $request = $this->getTemplateRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTemplate'
     *
     * @param  int $id The unique identifier of the document template. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTemplateRequest($id, string $contentType = self::contentTypes['getTemplate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getTemplate'
            );
        }


        $resourcePath = '/templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Auth-Token');
        if ($apiKey !== null) {
            $headers['X-Auth-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTemplates
     *
     * List all templates
     *
     * @param  string $q Filter templates based on the name partial match. (optional)
     * @param  string $external_id The unique applications-specific identifier provided for the template via API or Embedded template form builder. It allows you to receive only templates with your specified external id. (optional)
     * @param  string $folder Filter templates by folder name. (optional)
     * @param  bool $archived Get only archived templates instead of active ones. (optional)
     * @param  int $limit The number of templates to return. Default value is 10. Maximum value is 100. (optional)
     * @param  int $after The unique identifier of the template to start the list from. It allows you to receive only templates with id greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of templates. (optional)
     * @param  int $before The unique identifier of the template to end the list with. It allows you to receive only templates with id less than the specified value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplates'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Docuseal\Model\GetTemplates200Response
     */
    public function getTemplates($q = null, $external_id = null, $folder = null, $archived = null, $limit = null, $after = null, $before = null, string $contentType = self::contentTypes['getTemplates'][0])
    {
        list($response) = $this->getTemplatesWithHttpInfo($q, $external_id, $folder, $archived, $limit, $after, $before, $contentType);
        return $response;
    }

    /**
     * Operation getTemplatesWithHttpInfo
     *
     * List all templates
     *
     * @param  string $q Filter templates based on the name partial match. (optional)
     * @param  string $external_id The unique applications-specific identifier provided for the template via API or Embedded template form builder. It allows you to receive only templates with your specified external id. (optional)
     * @param  string $folder Filter templates by folder name. (optional)
     * @param  bool $archived Get only archived templates instead of active ones. (optional)
     * @param  int $limit The number of templates to return. Default value is 10. Maximum value is 100. (optional)
     * @param  int $after The unique identifier of the template to start the list from. It allows you to receive only templates with id greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of templates. (optional)
     * @param  int $before The unique identifier of the template to end the list with. It allows you to receive only templates with id less than the specified value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplates'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Docuseal\Model\GetTemplates200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTemplatesWithHttpInfo($q = null, $external_id = null, $folder = null, $archived = null, $limit = null, $after = null, $before = null, string $contentType = self::contentTypes['getTemplates'][0])
    {
        $request = $this->getTemplatesRequest($q, $external_id, $folder, $archived, $limit, $after, $before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Docuseal\Model\GetTemplates200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Docuseal\Model\GetTemplates200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Docuseal\Model\GetTemplates200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Docuseal\Model\GetTemplates200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Docuseal\Model\GetTemplates200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTemplatesAsync
     *
     * List all templates
     *
     * @param  string $q Filter templates based on the name partial match. (optional)
     * @param  string $external_id The unique applications-specific identifier provided for the template via API or Embedded template form builder. It allows you to receive only templates with your specified external id. (optional)
     * @param  string $folder Filter templates by folder name. (optional)
     * @param  bool $archived Get only archived templates instead of active ones. (optional)
     * @param  int $limit The number of templates to return. Default value is 10. Maximum value is 100. (optional)
     * @param  int $after The unique identifier of the template to start the list from. It allows you to receive only templates with id greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of templates. (optional)
     * @param  int $before The unique identifier of the template to end the list with. It allows you to receive only templates with id less than the specified value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplatesAsync($q = null, $external_id = null, $folder = null, $archived = null, $limit = null, $after = null, $before = null, string $contentType = self::contentTypes['getTemplates'][0])
    {
        return $this->getTemplatesAsyncWithHttpInfo($q, $external_id, $folder, $archived, $limit, $after, $before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTemplatesAsyncWithHttpInfo
     *
     * List all templates
     *
     * @param  string $q Filter templates based on the name partial match. (optional)
     * @param  string $external_id The unique applications-specific identifier provided for the template via API or Embedded template form builder. It allows you to receive only templates with your specified external id. (optional)
     * @param  string $folder Filter templates by folder name. (optional)
     * @param  bool $archived Get only archived templates instead of active ones. (optional)
     * @param  int $limit The number of templates to return. Default value is 10. Maximum value is 100. (optional)
     * @param  int $after The unique identifier of the template to start the list from. It allows you to receive only templates with id greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of templates. (optional)
     * @param  int $before The unique identifier of the template to end the list with. It allows you to receive only templates with id less than the specified value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplatesAsyncWithHttpInfo($q = null, $external_id = null, $folder = null, $archived = null, $limit = null, $after = null, $before = null, string $contentType = self::contentTypes['getTemplates'][0])
    {
        $returnType = '\Docuseal\Model\GetTemplates200Response';
        $request = $this->getTemplatesRequest($q, $external_id, $folder, $archived, $limit, $after, $before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTemplates'
     *
     * @param  string $q Filter templates based on the name partial match. (optional)
     * @param  string $external_id The unique applications-specific identifier provided for the template via API or Embedded template form builder. It allows you to receive only templates with your specified external id. (optional)
     * @param  string $folder Filter templates by folder name. (optional)
     * @param  bool $archived Get only archived templates instead of active ones. (optional)
     * @param  int $limit The number of templates to return. Default value is 10. Maximum value is 100. (optional)
     * @param  int $after The unique identifier of the template to start the list from. It allows you to receive only templates with id greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of templates. (optional)
     * @param  int $before The unique identifier of the template to end the list with. It allows you to receive only templates with id less than the specified value. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTemplatesRequest($q = null, $external_id = null, $folder = null, $archived = null, $limit = null, $after = null, $before = null, string $contentType = self::contentTypes['getTemplates'][0])
    {









        $resourcePath = '/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_id,
            'external_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $folder,
            'folder', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $archived,
            'archived', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after,
            'after', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Auth-Token');
        if ($apiKey !== null) {
            $headers['X-Auth-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mergeTemplate
     *
     * Merge templates
     *
     * @param  \Docuseal\Model\MergeTemplateRequest $merge_template_request merge_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeTemplate'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Docuseal\Model\GetTemplates200ResponseDataInner
     */
    public function mergeTemplate($merge_template_request, string $contentType = self::contentTypes['mergeTemplate'][0])
    {
        list($response) = $this->mergeTemplateWithHttpInfo($merge_template_request, $contentType);
        return $response;
    }

    /**
     * Operation mergeTemplateWithHttpInfo
     *
     * Merge templates
     *
     * @param  \Docuseal\Model\MergeTemplateRequest $merge_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeTemplate'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Docuseal\Model\GetTemplates200ResponseDataInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function mergeTemplateWithHttpInfo($merge_template_request, string $contentType = self::contentTypes['mergeTemplate'][0])
    {
        $request = $this->mergeTemplateRequest($merge_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Docuseal\Model\GetTemplates200ResponseDataInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Docuseal\Model\GetTemplates200ResponseDataInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Docuseal\Model\GetTemplates200ResponseDataInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Docuseal\Model\GetTemplates200ResponseDataInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Docuseal\Model\GetTemplates200ResponseDataInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mergeTemplateAsync
     *
     * Merge templates
     *
     * @param  \Docuseal\Model\MergeTemplateRequest $merge_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergeTemplateAsync($merge_template_request, string $contentType = self::contentTypes['mergeTemplate'][0])
    {
        return $this->mergeTemplateAsyncWithHttpInfo($merge_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mergeTemplateAsyncWithHttpInfo
     *
     * Merge templates
     *
     * @param  \Docuseal\Model\MergeTemplateRequest $merge_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergeTemplateAsyncWithHttpInfo($merge_template_request, string $contentType = self::contentTypes['mergeTemplate'][0])
    {
        $returnType = '\Docuseal\Model\GetTemplates200ResponseDataInner';
        $request = $this->mergeTemplateRequest($merge_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mergeTemplate'
     *
     * @param  \Docuseal\Model\MergeTemplateRequest $merge_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function mergeTemplateRequest($merge_template_request, string $contentType = self::contentTypes['mergeTemplate'][0])
    {

        // verify the required parameter 'merge_template_request' is set
        if ($merge_template_request === null || (is_array($merge_template_request) && count($merge_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merge_template_request when calling mergeTemplate'
            );
        }


        $resourcePath = '/templates/merge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($merge_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($merge_template_request));
            } else {
                $httpBody = $merge_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Auth-Token');
        if ($apiKey !== null) {
            $headers['X-Auth-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTemplate
     *
     * Update a template
     *
     * @param  int $id The unique identifier of the document template. (required)
     * @param  \Docuseal\Model\UpdateTemplateRequest $update_template_request update_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplate'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Docuseal\Model\UpdateTemplate200Response
     */
    public function updateTemplate($id, $update_template_request, string $contentType = self::contentTypes['updateTemplate'][0])
    {
        list($response) = $this->updateTemplateWithHttpInfo($id, $update_template_request, $contentType);
        return $response;
    }

    /**
     * Operation updateTemplateWithHttpInfo
     *
     * Update a template
     *
     * @param  int $id The unique identifier of the document template. (required)
     * @param  \Docuseal\Model\UpdateTemplateRequest $update_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplate'] to see the possible values for this operation
     *
     * @throws \Docuseal\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Docuseal\Model\UpdateTemplate200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTemplateWithHttpInfo($id, $update_template_request, string $contentType = self::contentTypes['updateTemplate'][0])
    {
        $request = $this->updateTemplateRequest($id, $update_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Docuseal\Model\UpdateTemplate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Docuseal\Model\UpdateTemplate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Docuseal\Model\UpdateTemplate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Docuseal\Model\UpdateTemplate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Docuseal\Model\UpdateTemplate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateTemplateAsync
     *
     * Update a template
     *
     * @param  int $id The unique identifier of the document template. (required)
     * @param  \Docuseal\Model\UpdateTemplateRequest $update_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTemplateAsync($id, $update_template_request, string $contentType = self::contentTypes['updateTemplate'][0])
    {
        return $this->updateTemplateAsyncWithHttpInfo($id, $update_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTemplateAsyncWithHttpInfo
     *
     * Update a template
     *
     * @param  int $id The unique identifier of the document template. (required)
     * @param  \Docuseal\Model\UpdateTemplateRequest $update_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTemplateAsyncWithHttpInfo($id, $update_template_request, string $contentType = self::contentTypes['updateTemplate'][0])
    {
        $returnType = '\Docuseal\Model\UpdateTemplate200Response';
        $request = $this->updateTemplateRequest($id, $update_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTemplate'
     *
     * @param  int $id The unique identifier of the document template. (required)
     * @param  \Docuseal\Model\UpdateTemplateRequest $update_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateTemplateRequest($id, $update_template_request, string $contentType = self::contentTypes['updateTemplate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateTemplate'
            );
        }

        // verify the required parameter 'update_template_request' is set
        if ($update_template_request === null || (is_array($update_template_request) && count($update_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_template_request when calling updateTemplate'
            );
        }


        $resourcePath = '/templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_template_request));
            } else {
                $httpBody = $update_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Auth-Token');
        if ($apiKey !== null) {
            $headers['X-Auth-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
